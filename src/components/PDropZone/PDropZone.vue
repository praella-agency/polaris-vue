<template>
    <div :style="styleBasedOnSize">
        <PLabelled
            :id="id"
            :label="label"
            :action="labelAction"
            :labelHidden="label ? labelHidden : true"
        >
            <div
                ref="node"
                :class="className"
                :aria-disabled="disabled"
                @click="handleOnClick"
                @dragstart="stopEvent"
            >
                <template
                    v-if="(active || dragging) && !intervalError && !error && overlay"
                >
                    <div
                        :class="overlayClassName"
                    >
                        <PStack vertical spacing="tight">
                            <!--                            <PIcon v-if="size === 'small'" source="UploadMajor" color="interactive"/>-->
                            <PDisplayText v-if="size === 'extraLarge'" size="small" element="p">
                                {{ overlayTextWithDefault }}
                            </PDisplayText>
                        </PStack>
                    </div>
                </template>
                <template
                    v-if="dragging && (intervalError || error)"
                >
                    <div
                        :class="overlayClassName"
                    >
                        <PStack vertical spacing="tight">
                            <!--                            <PIcon v-if="size === 'small'" source="CircleAlertMajor" color="critical"/>-->
                            <PDisplayText v-if="size === 'extraLarge'" size="small" element="p">
                                {{ errorOverlayTextWithDefault }}
                            </PDisplayText>
                        </PStack>
                    </div>
                </template>
                <span class="Polaris-VisuallyHidden">
                    <!--
                        Triggered on focus
                        @event focus
                    -->
                    <!--
                        Triggered on blur
                        @event blur
                    -->
                    <PDropZoneInput
                        :id="id"
                        :accept="accept"
                        :disabled="disabled"
                        :type="type"
                        :multiple="allowMultiple"
                        @change="handleDrop"
                        @focus="emit('focus', $event)"
                        @blur="emit('blur', $event)"
                        :openFileDialog="openFileDialog"
                        :onFileDialogClose="handleOnFileDialogClose"
                    />
                </span>
                <div class="Polaris-DropZone__Container">
                    <PFileUpload
                        v-if="!files.length"
                        :disabled="disabled"
                        :variableHeight="variableHeight"
                        :size="size"
                        :actionTitle="actionTitle"
                        :actionHint="actionHint"
                    />
                    <!-- @slot Preview uploaded files -->
                    <slot name="uploadFiles" v-if="uploadedFiles && files.length > 0">
                        <PStack
                            v-for="(file, key) in files"
                            :key="key"
                            alignment="center"
                        >
                            <PStackItem>
                                <PThumbnail
                                    size="small"
                                    :alt="file.name"
                                    :source="validImageTypes.indexOf(file.type) > -1
                                                 ? createFileURL(file)
                                                 : NoteMinor"
                                />
                            </PStackItem>
                            <PStackItem>
                                <div>
                                    {{ file.name }}
                                    <PCaption>{{ file.size }} bytes</PCaption>
                                </div>
                            </PStackItem>
                            <PStackItem>
                                <PIcon
                                    source="CircleCancelMinor"
                                    color="critical"
                                    @click.native.stop="removeFiles(key)"
                                />
                            </PStackItem>
                        </PStack>
                    </slot>
                </div>
            </div>
        </PLabelled>
    </div>
</template>

<script setup>
    import { ref, computed, onMounted, onUnmounted  } from 'vue';
    import { uuid } from '../../ComponentHelpers';
    import { classNames, variationName } from '../../utilities/css';
    import { PIcon } from '../../components/PIcon';
    import { PStack } from '../../components/PStack';
    import { PStackItem } from '../../components/PStack/components/PStackItem';
    import { PCaption } from '../../components/PCaption';
    import { PDisplayText } from '../../components/PDisplayText';
    import { PFileUpload } from '../../components/PDropZone/components/PFileUpload';
    import { PDropZoneInput } from '../../components/PDropZone/components/PDropZoneInput';
    import { PLabelled } from '../../components/PLabelled';
    import { PThumbnail } from '../../components/PThumbnail';
    import { NoteMinor } from '../../assets/shopify-polaris-icons';
    import { fileAccepted, isServer, getDataTransferFiles, useToggle } from './context';
    import { DropZoneFileType, focused } from '../variables';

    /**
     * <br/>
     * <h4 style="font-family: -apple-system, BlinkMacSystemFont, San Francisco, Segoe UI, Roboto, Helvetica Neue,
     *  sans-serif;">The drop zone component lets users upload files by dragging and dropping the files into an area on a
     *  page, or activating a button.</h4>
     */

    let props = defineProps({
        /**
         * Label for the file input
         */
        label: {
            type: String,
            default: null,
        },
        /**
         * Adds an action to the label
         */
        labelAction: {
            type: Object,
        },
        /**
         * Visually hide the label
         */
        labelHidden: {
            type: Boolean,
            default: false,
        },
        /**
         * ID for file input
         */
        id: {
            type: [Number, String],
            default: `PDropZone${uuid()}`,
        },
        /**
         * Allowed file types
         */
        accept: {
            type: String,
            default: null,
        },
        /**
         * Whether is a file or an image
         * @default 'file'
         */
        type: {
            type: [String, DropZoneFileType],
            default: 'file',
        },
        /**
         * Sets an active state
         */
        active: {
            type: Boolean,
            default: false,
        },
        /**
         * Sets an error state
         */
        error: {
            type: Boolean,
            default: false,
        },
        /**
         * Displays an outline border
         * @default true
         */
        outline: {
            type: Boolean,
            default: true,
        },
        /**
         * Displays an overlay on hover
         * @default true
         */
        overlay: {
            type: Boolean,
            default: true,
        },
        /**
         * Text that appears in the overlay
         */
        overlayText: {
            type: String,
            default: null,
        },
        /**
         * Text that appears in the overlay when set in error state
         */
        errorOverlayText: {
            type: String,
            default: null,
        },
        /**
         * Allows multiple files to be uploaded at once
         * @default true
         */
        allowMultiple: {
            type: Boolean,
            default: true,
        },
        /**
         * Sets a disabled state
         */
        disabled: {
            type: Boolean,
            default: false,
        },
        /**
         * Allows a file to be dropped anywhere on the page
         */
        dropOnPage: {
            type: Boolean,
            default: false,
        },
        /**
         * Sets the default file dialog state
         */
        openFileDialog: {
            type: Boolean,
            default: false,
        },
        /**
         * Allows child content to adjust height
         */
        variableHeight: {
            type: Boolean,
            default: false,
        },
        // /**
        //  * Adds custom validations
        //  */
        // customValidator: {
        //     type: Boolean,
        //     default: false,
        // },
        /**
         *  Callback triggered on any file drop
         */
        handleOnDrop: {
            type: Function,
            // tslint:disable-next-line:no-empty
            default: (files, acceptedFiles, rejectedFiles) => ({}),
            required: true,
        },
        /**
         * Callback triggered when at least one of the files dropped was accepted
         */
        handleOnDropAccepted: {
            type: Function,
            // tslint:disable-next-line:no-empty
            default: (acceptedFiles) => ({}),
        },
        /**
         * Callback triggered when at least one of the files dropped was rejected
         */
        handleOnDropRejected: {
            type: Function,
            // tslint:disable-next-line:no-empty
            default: (rejectedFiles) => ({}),
        },
        /**
         * Callback triggered when one or more files are dragging over the drag area
         */
        handleOnDragOver: {
            type: Function,
            // tslint:disable-next-line:no-empty
            default: () => ({}),
        },
        /**
         * Callback triggered when one or more files entered the drag area
         */
        handleOnDragEnter: {
            type: Function,
            // tslint:disable-next-line:no-empty
            default: () => ({}),
        },
        /**
         * Callback triggered when one or more files left the drag area
         */
        handleOnDragLeave: {
            type: Function,
            // tslint:disable-next-line:no-empty
            default: () => ({}),
        },
        /**
         * Callback triggered when the file dialog is canceled
         */
        handleOnFileDialogClose: {
            type: Function,
            // tslint:disable-next-line:no-empty
            default: () => ({}),
        },
        /**
         * Files
         */
        files: {
            type: Array,
            default: () => ([]),
            required: true,
        },
        /**
         * Display Uploaded Files in DropZone
         */
        uploadedFiles: {
            type: Boolean,
            default: true,
        },
        // /**
        //  * Change size of the DropZone
        //  */
        // size: {
        //     type: String,
        //     default: 'extraLarge',
        // },
        /**
         * Valid Image Types to preview images
         */
        validImageTypes: {
            type: Array,
            default: () => ['image/gif', 'image/jpeg', 'image/png'],
        },
        /**
         * Set the actionTitle
         */
        actionTitle: {
            type: String,
            default: `Add files`,
        },
        /**
         * Set the actionHint
         */
        actionHint: {
            type: String,
            default: `or drop files to upload`,
        },
    });
    const emit = defineEmits(['focus', 'blur']);

    let dragTargets = ref([]);
    let size = ref('extraLarge');
    let dragging = ref(false);
    let intervalError = ref(false);
    let measuring = ref(true);
    let node = ref(null);

    let className = computed(() => {
        return classNames(
            'Polaris-DropZone',
            props.outline && 'Polaris-DropZone--hasOutline',
            focused && 'Polaris-DropZone--focused',
            (props.active || dragging.value) && 'Polaris-DropZone--isDragging',
            props.disabled && 'Polaris-DropZone--isDisabled',
            (intervalError.value || props.error) && 'Polaris-DropZone--hasError',
            !props.variableHeight && `Polaris-DropZone--${variationName('size', size.value)}`,
            measuring.value && 'Polaris-DropZone--measuring',
        );
    });

    let overlayClassName = computed(() => {
        return classNames(
            'Polaris-DropZone__Overlay',
        );
    });

    let overlayTextWithDefault = computed(() => {
        if (!props.overlayText && props.allowMultiple) {
            return 'Drop files to upload';
        } else if (!props.overlayText && !props.allowMultiple) {
            return 'Drop file to upload';
        } else {
            return props.overlayText;
        }
    });

    let errorOverlayTextWithDefault = computed(() => {
        if (!props.errorOverlayText) {
            return 'File type is not valid';
        } else {
            return props.errorOverlayText;
        }
    });

    let context = computed(() => {
        const type = props.type || 'file';
        return [props.disabled, focused, size.value, type, props.measuring, props.allowMultiple];
    });

    let styleBasedOnSize = computed(() => {
        // if (this.size === 'small') {
        //   return 'width: 50px; height: 50px;';
        // } else if(this.size === 'medium') {
        //   return 'width: 114px; height: 114px;';
        // }
        return '';
    });

    function stopEvent(event) {
        event.preventDefault();
        event.stopPropagation();
    }

    function getValidatedFiles(files) {
        const acceptedFiles = [];
        const rejectedFiles = [];

        Array.from(files).forEach((file) => {
            !fileAccepted(file, props.accept) ? rejectedFiles.push(file) : acceptedFiles.push(file);
        });

        if (!props.allowMultiple) {
            acceptedFiles.slice(1, acceptedFiles.length);
            rejectedFiles.push(...acceptedFiles.slice(1));
        }

        return {files, acceptedFiles, rejectedFiles};
    }

    function handleDrop(event) {
        stopEvent(event);
        if (props.disabled) {
            return;
        }
        const fileList = getDataTransferFiles(event);

        const {files, acceptedFiles, rejectedFiles} = getValidatedFiles(fileList);

        dragTargets.value = [];
        dragging.value = false;
        intervalError.value = rejectedFiles.length > 0;

        // tslint:disable-next-line:no-unused-expression
        props.handleOnDrop && props.handleOnDrop(files, acceptedFiles, rejectedFiles);
        // tslint:disable-next-line:no-unused-expression
        props.handleOnDropAccepted && acceptedFiles.length && props.handleOnDropAccepted(acceptedFiles);
        // tslint:disable-next-line:no-unused-expression
        props.handleOnDropRejected && rejectedFiles.length && props.handleOnDropRejected(rejectedFiles);

        (event.target).value = '';
    }

    function handleDragOver(event) {
        stopEvent(event);
        if (props.disabled) {
            return;
        }
        // tslint:disable-next-line:no-unused-expression
        props.handleOnDragOver && props.handleOnDragOver();
    }

    function handleDragEnter(event) {
        stopEvent(event);
        if (props.disabled) {
            return;
        }

        const fileList = getDataTransferFiles(event);

        if (event.target && !dragTargets.value.includes(event.target)) {
            dragTargets.value.push(event.target);
        }

        if (dragging.value) {
            return;
        }

        const {rejectedFiles} = getValidatedFiles(fileList);
        dragging.value = true;
        intervalError.value = rejectedFiles.length > 0;

        // tslint:disable-next-line:no-unused-expression
        props.handleOnDragEnter && props.handleOnDragEnter();
    }

    function handleDragLeave(event) {
        event.preventDefault();

        if (props.disabled) {
            return;
        }

        dragTargets.value = dragTargets.value.filter((el) => {
            const compareNode = props.dropOnPage && !isServer ? document : node;

            return el !== event.target && compareNode && compareNode.contains(el);
        });

        if (dragTargets.value.length > 0) {
            return;
        }

        dragging.value = false;
        intervalError.value = false;

        // tslint:disable-next-line:no-unused-expression
        props.handleOnDragLeave && props.handleOnDragLeave();
    }

    function adjustSize() {
        if (!node) {
            return;
        }

        if (props.variableHeight) {
            measuring.value = false;
            return;
        }

        let reSize = 'extraLarge';
        const width = node.getBoundingClientRect().width;

        if (width < 100) {
            reSize = 'small';
        } else if (width < 160) {
            reSize = 'medium';
        } else if (width < 300) {
            reSize = 'large';
        }

        size.value = reSize;
        // tslint:disable-next-line:no-unused-expression
        measuring.value && (measuring.value = false);
    }

    /**
     * Callback triggered on click
     */
    function handleOnClick() {
        if (props.disabled) {
            return;
        }

        return onclick ? onclick : open();
    }

    function open() {
        const fileInputNode = node && node.querySelector(`#${props.id}`);
        // tslint:disable-next-line:no-unused-expression
        fileInputNode && fileInputNode instanceof HTMLElement && fileInputNode.click();
    }

    function createFileURL(file) {
        return window.URL.createObjectURL(file);
    }

    function removeFiles(key) {
        props.files.splice(key, 1);
    }

    onMounted(() => {
        node = node.value;
        adjustSize();
        const dropNode = props.dropOnPage ? document : node;
        if (!dropNode) {
            return;
        }

        dropNode.addEventListener('drop', handleDrop);
        dropNode.addEventListener('dragover', handleDragOver);
        dropNode.addEventListener('dragenter', handleDragEnter);
        dropNode.addEventListener('dragleave', handleDragLeave);
        window.addEventListener('resize', adjustSize);
    });

    onUnmounted(() => {
        const dropNode = props.dropOnPage ? document : node;
        if (!dropNode) {
            return;
        }

        dropNode.removeEventListener('drop', handleDrop);
        dropNode.removeEventListener('dragover', handleDragOver);
        dropNode.removeEventListener('dragenter', handleDragEnter);
        dropNode.removeEventListener('dragleave', handleDragLeave);
        window.removeEventListener('resize', adjustSize);
    });
</script>
