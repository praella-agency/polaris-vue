<template>
    <div :class="parentClassName">
        <div class="Polaris-Labelled__LabelWrapper">
            <div class="Polaris-Label">
                <!-- @slot Display label for an element -->
                <slot name="label">
                    <label :id="`${id}Label`" :for="id" class="Polaris-Label__Text">
                        {{ label }}
                    </label>
                </slot>
            </div>
        </div>
        <div :class="className">
            <!--
             Triggers on searchChange
             @event searchChange
             -->
            <MultiSelect
                :id="id"
                v-model="computedValue"
                v-bind="$attrs"
                :disabled="disabled"
                aria-invalid="false"
                :options="computedOptions"
                :track-by="valueField"
                :placeholder="!floatingLabel ? placeholder : null"
                :searchable="searchable"
                :multiple="multiple"
                :taggable="taggable"
                :close-on-select="computedMultiple"
                :clear-on-select="false"
                :preserve-search="true"
                :label="textField"
                @open="handleOpen"
                @close="handleClose"
                @tag="addTag"
                @search-change="(query) => {$emit('searchChange', query)}"
            >
                <template v-slot:caret>
                    <div v-if="!floatingLabel" class="multiselect__select">
                        <PIcon source="SelectMinor"/>
                    </div>
                    <div v-else class="multiselect__select">
                        <PIcon source="CaretDownMinor"/>
                    </div>
                </template>

                <template v-slot:selection="{values, search, remove, isOpen}">
                    <div class="multiselect__tags-wrap" v-show="values && values.length > 0">
                        <template v-for="(option, index) of values" @mousedown.prevent>
                            <PTag
                                :tag="{
                                    'value': option[textField],
                                    'key': option[valueField]
                                }"
                                removable
                                :size="floatingLabel ? 'small' : ''"
                                @remove-tag="remove(option)"
                            />
                        </template>
                    </div>
                    <template slot="limit"></template>
                </template>
            </MultiSelect>
        </div>
        <div class="Polaris-Labelled__HelpText" v-if="helpText">{{ helpText }}</div>
        <PFieldError v-if="error" :error="error"/>
    </div>
</template>

<script>
    import utils from '../../utilities';
    import { uuid } from '../../ComponentHelpers';
    import { classNames } from '../../utilities/css';
    import { MultiSelect } from './components';
    import { PIcon } from '../../components/PIcon';
    import { PTag } from '../../components/PTag';
    import { PFieldError } from '../../components/PFieldError';

    export default {
        name: 'PMultiSelect',
        components: {
            PIcon, PTag, PFieldError,
            MultiSelect,
        },
        props: {
            /**
             * Disable the PMultiSelect.
             */
            disabled: {
                type: Boolean,
                default: false,
            },
            /**
             * Label for the PMultiSelect.
             */
            label: {
                type: String,
                default: null,
            },
            /**
             * Options of PMultiSelect.
             */
            options: {
                type: Array,
                required: true,
                default: () => ([]),
            },
            /**
             * Field name in the `options` array that should be used for the text label
             */
            textField: {
                type: String,
                default: 'label',
            },
            /**
             * Field name in the `options` array that should be used for the value
             */
            valueField: {
                type: String,
                default: 'value',
            },
            /**
             * Field name in the `options` array that should be used for the disabled state
             */
            disabledField: {
                type: String,
                default: 'disabled',
            },
            /**
             * Value for PMultiSelect.
             */
            value: {
                type: [String, Object, Array, Number, Boolean],
                default: () => ([]),
            },
            /**
             * Model value for PMultiSelect.
             */
            modelValue: {
                type: [String, Object, Array, Number, Boolean],
                default: () => ([]),
            },
            /**
             * Disable the searchable options feature.
             */
            searchable: {
                type: Boolean,
                default: true,
            },
            /**
             * Taggable provides ability to add new user-input value on multiselect.
             */
            taggable: {
                type: Boolean,
                default: false,
            },
            /**
             * Provide Placeholder.
             */
            placeholder: {
                type: String,
                default: null,
            },
            /**
             * Help text
             */
            helpText: {
                type: String,
                default: null,
            },
            /**
             * Validation error
             */
            error: {
                type: String,
                default: null,
            },
            /**
             * To allow multiple selections
             */
            multiple: {
                type: Boolean,
                default: true,
            },
            /**
             * Id for the element
             */
            id: {
                type: [String, Number],
                default: `PolarisMultiSelect${uuid()}`,
            },
            /**
             * Create beautifully simple form labels that float over your input fields
             */
            floatingLabel: {
                type: Boolean,
                default: false,
            },
            /**
             * Return object
             */
            returnObject: {
                type: Boolean,
                default: true
            }
        },
        emits: ['change', 'input', 'searchChange', 'update:modelValue', 'update:value'],
        data() {
            return {
                selected: this.value,
                dropdownOpen: false,
                taggableOptions: [],
            };
        },
        computed: {
            computedVModel() {
                if (utils.isVue3) {
                    return this.modelValue;
                }
                return this.value;
            },
            parentClassName() {
                return classNames(
                    this.floatingLabel && 'Polaris-Select-Floating-Label',
                    this.hasValue && 'Polaris-Select-Has-Value',
                    this.dropdownOpen && 'Polaris-Select--Active',
                );
            },
            className() {
                return classNames(
                    'Polaris-Select',
                    this.disabled && 'Polaris-Select--disabled',
                    this.error && 'invalid',
                );
            },
            computedOptions() {
                const options = [];
                this.options.map((value) => {
                    if (typeof value === 'object') {
                        if (value[this.disabledField]) {
                            value.$isDisabled = value[this.disabledField];
                        }
                        options.push(value);
                    } else {
                        options.push({[this.textField]: value, [this.valueField]: value});
                    }
                });
                this.taggableOptions.map((value) => {
                    if (typeof value === 'object') {
                        if (value[this.disabledField]) {
                            value.$isDisabled = value[this.disabledField];
                        }
                        options.push(value);
                    } else {
                        options.push({[this.textField]: value, [this.valueField]: value});
                    }
                });
                return options;
            },
            hasValue() {
                if (this.multiple) {
                    return this.selected && this.selected.length > 0;
                } else {
                    return !!this.selected;
                }
            },
            computedValue: {
                get() {
                    return this.selected;
                },
                set(value) {
                    this.selected = value;
                    this.emitUpdateEvents();
                },
            },
            computedMultiple() {
                return !this.multiple;
            },
        },
        methods: {
            addTag(newTag) {
                const tag = {
                    [this.textField]: newTag,
                    [this.valueField]: newTag,
                };
                this.taggableOptions.push(tag);
                if (this.multiple) {
                    this.selected.push(tag);
                } else {
                    this.selected = tag;
                }
                this.emitUpdateEvents();
            },
            handleOpen() {
                this.dropdownOpen = true;
            },
            handleClose() {
                this.dropdownOpen = false;
            },
            emitUpdateEvents() {
                const computedValue = this.computedValue;
                let values = [];
                if (!this.multiple) {
                    values = null;
                    if(computedValue) {
                        values = computedValue[this.valueField];
                    }
                }
                if (this.multiple && Array.isArray(computedValue) && computedValue.length ) {
                    computedValue.forEach(item => {
                        values.push(item[this.valueField] || null);
                    });
                }
                /**
                 * Callback when selection is changed
                 */
                this.$emit('change', this.returnObject ? computedValue : values);
                /**
                 * Callback when input is triggered
                 */
                this.$emit('input', this.returnObject ? computedValue : values);
                /**
                 * Callback when input is triggered
                 * @ignore
                 */
                this.$emit('update:modelValue', this.returnObject ? computedValue : values);
                /**
                 * Callback when input is triggered
                 * @ignore
                 */
                this.$emit('update:value', this.returnObject ? computedValue : values);
            }
        },
        watch: {
            value(value) {
                this.selected = value;
            },
        },
        created() {
            this.selected = this.computedVModel || (this.multiple ? [] : null);
        }
    }
</script>

